#!/usr/bin/env python3

import rospy
from duckietown_msgs.msg import WheelEncoderStamped, Twist2DStamped, FSMState
from sensor_msgs.msg import Joy
import math

class ClosedLoopSquare:
    def __init__(self):
        rospy.init_node('closed_loop_square_node', anonymous=True)
        rospy.loginfo("Node initialized")

        self.cmd_msg = Twist2DStamped()
        self.pub = rospy.Publisher('/jeff/car_cmd_switch_node/cmd', Twist2DStamped, queue_size=1)
        rospy.Subscriber('/jeff/right_wheel_encoder_node/tick', WheelEncoderStamped, self.encoder_callback)
        rospy.Subscriber('/jeff/fsm_node/mode', FSMState, self.fsm_callback, queue_size=1)
        rospy.Subscriber('/joy', Joy, self.joy_callback)

        self.ticks_per_meter = 345
        self.ticks_per_90_deg = 100
        self.ticks_per_deg = self.ticks_per_90_deg / 90.0

        self.linear_speed = 0.5
        self.angular_speed = 0.5

        self.break_time = rospy.Duration(1.0)
        self.break_start = None

        self.right_ticks = 0
        self.tasks = []
        self.current_task = None
        self.is_running = False

        self.external_move_active = False
        self.external_move_type = None
        self.external_start_ticks = 0
        self.external_target_ticks = 0
        self.external_direction = 1
        self.external_linear_speed = 0.0
        self.external_angular_speed = 0.0

        timer_period = 0.01
        rospy.Timer(rospy.Duration(timer_period), self.timer_callback)

    def fsm_callback(self, msg):
        if msg.state == "NORMAL_JOYSTICK_CONTROL":
            rospy.loginfo("Joystick control mode")
            self.is_running = False
            self.stop_robot()
        elif msg.state == "LANE_FOLLOWING":
            rospy.loginfo("Starting closed-loop square")
            self.is_running = True
            self.tasks = []
            for _ in range(4):
                self.tasks.append({'action': 'move', 'ticks': self.ticks_per_meter})
                self.tasks.append({'action': 'turn', 'ticks': self.ticks_per_90_deg})
            self.current_task = None
            self.break_start = None

    def joy_callback(self, msg):
        if msg.buttons[0]:  # A - move forward
            self.move_distance_command(1.0, 0.2)
        elif msg.buttons[1]:  # B - move backward
            self.move_distance_command(-1.0, 0.4)
        elif msg.buttons[4]:  # LB - rotate CCW
            self.rotate_angle_command(90, 0.3)
        elif msg.buttons[5]:  # RB - rotate CW
            self.rotate_angle_command(-90, 0.6)

    def encoder_callback(self, msg):
        self.right_ticks = msg.data

    def stop_robot(self):
        self.cmd_msg.header.stamp = rospy.Time.now()
        self.cmd_msg.v = 0.0
        self.cmd_msg.omega = 0.0
        self.pub.publish(self.cmd_msg)

    def move_distance_command(self, distance_meters, speed):
        self.external_move_active = True
        self.external_move_type = 'move'
        self.external_start_ticks = self.right_ticks
        self.external_target_ticks = abs(distance_meters * self.ticks_per_meter)
        self.external_direction = 1 if distance_meters > 0 else -1
        self.external_linear_speed = abs(speed)
        self.external_angular_speed = 0.0

    def rotate_angle_command(self, angle_degrees, speed):
        self.external_move_active = True
        self.external_move_type = 'turn'
        self.external_start_ticks = self.right_ticks
        self.external_target_ticks = abs(angle_degrees * self.ticks_per_deg)
        self.external_direction = 1 if angle_degrees > 0 else -1
        self.external_linear_speed = 0.0
        self.external_angular_speed = abs(speed)

    def execute_external_command(self):
        current_ticks = self.right_ticks - self.external_start_ticks
        if abs(current_ticks) >= abs(self.external_target_ticks):
            self.external_move_active = False
            self.stop_robot()
            rospy.loginfo("External command complete")
            return

        self.cmd_msg.header.stamp = rospy.Time.now()
        self.cmd_msg.v = self.external_linear_speed * self.external_direction
        self.cmd_msg.omega = self.external_angular_speed * self.external_direction
        self.pub.publish(self.cmd_msg)

    def move_distance(self, ticks, start):
        current_ticks = self.right_ticks - start
        if abs(current_ticks) >= abs(ticks):
            self.stop_robot()
            return True
        direction = 1 if ticks > 0 else -1
        self.cmd_msg.header.stamp = rospy.Time.now()
        self.cmd_msg.v = self.linear_speed * direction
        self.cmd_msg.omega = 0.0
        self.pub.publish(self.cmd_msg)
        return False

    def turn_90_deg(self, ticks, start):
        current_ticks = self.right_ticks - start
        if abs(current_ticks) >= abs(ticks):
            self.stop_robot()
            return True
        direction = 1 if ticks > 0 else -1
        self.cmd_msg.header.stamp = rospy.Time.now()
        self.cmd_msg.v = 0.0
        self.cmd_msg.omega = self.angular_speed * direction
        self.pub.publish(self.cmd_msg)
        return False

    def timer_callback(self, event):
        if self.external_move_active:
            self.execute_external_command()
            return

        if not self.is_running:
            return

        if self.break_start is not None:
            if (rospy.Time.now() - self.break_start) < self.break_time:
                return
            self.break_start = None

        if self.current_task is None:
            if not self.tasks:
                rospy.loginfo("Square pattern completed")
                self.is_running = False
                return
            self.current_task = self.tasks.pop(0)
            self.current_task['start'] = self.right_ticks
            rospy.loginfo(f"Starting {self.current_task['action']}")

        task_complete = False
        if self.current_task['action'] == 'move':
            task_complete = self.move_distance(self.current_task['ticks'], self.current_task['start'])
        elif self.current_task['action'] == 'turn':
            task_complete = self.turn_90_deg(self.current_task['ticks'], self.current_task['start'])

        if task_complete:
            self.current_task = None
            self.stop_robot()
            if self.tasks:
                self.break_start = rospy.Time.now()

    def run(self):
        rospy.spin()

if __name__ == '__main__':
    try:
        ClosedLoopSquare().run()
    except rospy.ROSInterruptException:
        pass
