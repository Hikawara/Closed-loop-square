#!/usr/bin/env python3

import rospy 
from duckietown_msgs.msg import WheelEncoderStamped, Twist2DStamped, FSMState
from sensor_msgs.msg import Joy

class ClosedLoopSquare:
    def __init__(self):
        # Initialize message
        self.cmd_msg = Twist2DStamped()

        # Initialize ROS node
        rospy.init_node('closed_loop_square_node', anonymous=True)
        rospy.loginfo("Node initialized")
        
        # Initialize publishers/subscribers
        self.pub = rospy.Publisher('/jeff/car_cmd_switch_node/cmd', Twist2DStamped, queue_size=1)
        rospy.Subscriber('/jeff/right_wheel_encoder_node/tick', WheelEncoderStamped, self.encoder_callback)
        rospy.Subscriber('/jeff/fsm_node/mode', FSMState, self.fsm_callback, queue_size=1)
        rospy.Subscriber('/joy', Joy, self.joy_callback)

        # Set the parameters
        self.ticks_per_meter = 345
        self.ticks_per_90_deg = 100

        # Set the control speeds
        self.linear_speed = 0.5
        self.angular_speed = 0.5
        
        # Task timing
        self.break_time = rospy.Duration(1.0)
        self.break_start = None
        
        # Initialize encoders and tasks
        self.right_ticks = 0
        self.tasks = []
        self.current_task = None
        self.is_running = False

        # External move command
        self.external_move_active = False
        self.external_move_params = None  # dict with 'ticks', 'start', 'speed'

        # Build square task queue
        self.reset_square_tasks()

        # Timer
        rospy.Timer(rospy.Duration(0.01), self.timer_callback)

    def reset_square_tasks(self):
        self.tasks = []
        for _ in range(4):
            self.tasks.append({'action': 'move', 'ticks': self.ticks_per_meter})
            self.tasks.append({'action': 'turn', 'ticks': self.ticks_per_90_deg})

    def fsm_callback(self, msg):
        if msg.state == "NORMAL_JOYSTICK_CONTROL":
            rospy.loginfo("Switching to joystick control")
            self.is_running = False
            self.stop_robot()
        elif msg.state == "LANE_FOLLOWING":
            rospy.loginfo("Starting square pattern")
            self.is_running = True
            self.external_move_active = False
            self.external_move_params = None
            self.current_task = None
            self.break_start = None
            self.reset_square_tasks()

    def stop_robot(self):
        self.cmd_msg.header.stamp = rospy.Time.now()
        self.cmd_msg.v = 0.0
        self.cmd_msg.omega = 0.0
        self.pub.publish(self.cmd_msg)

    def encoder_callback(self, msg):
        self.right_ticks = msg.data

    def joy_callback(self, msg):
        if not self.is_running:
            return
        
        A = msg.buttons[0]
        B = msg.buttons[1]
        X = msg.buttons[2]
        Y = msg.buttons[3]

        if A:
            self.move_distance_command(1.0, 0.3)  # forward slow
        elif B:
            self.move_distance_command(-1.0, 0.3)  # backward slow
        elif X:
            self.move_distance_command(1.0, 0.6)  # forward fast
        elif Y:
            self.move_distance_command(-1.0, 0.6)  # backward fast

    def move_distance_command(self, meters, speed):
        ticks = int(meters * self.ticks_per_meter)
        rospy.loginfo(f"Commanded move: {meters:.2f} m at {speed:.2f} m/s ({ticks} ticks)")
        self.external_move_active = True
        self.external_move_params = {
            'ticks': ticks,
            'start': self.right_ticks,
            'speed': abs(speed)  # speed magnitude
        }

    def move_distance(self, ticks, start):
        current_ticks = self.right_ticks - start
        if abs(current_ticks) >= abs(ticks):
            rospy.loginfo("Move complete")
            self.stop_robot()
            return True
        
        direction = 1 if ticks > 0 else -1
        self.cmd_msg.header.stamp = rospy.Time.now()
        self.cmd_msg.v = self.linear_speed * direction
        self.cmd_msg.omega = 0.0
        self.pub.publish(self.cmd_msg)
        return False

    def turn_90_deg(self, ticks, start):
        current_ticks = self.right_ticks - start
        if abs(current_ticks) >= abs(ticks):
            rospy.loginfo("Turn complete")
            self.stop_robot()
            return True
        
        direction = 1 if ticks > 0 else -1
        self.cmd_msg.header.stamp = rospy.Time.now()
        self.cmd_msg.v = 0.0
        self.cmd_msg.omega = self.angular_speed * direction
        self.pub.publish(self.cmd_msg)
        return False

    def timer_callback(self, event):
        if not self.is_running:
            return

        # External move logic
        if self.external_move_active and self.external_move_params:
            params = self.external_move_params
            current_ticks = self.right_ticks - params['start']
            if abs(current_ticks) >= abs(params['ticks']):
                rospy.loginfo("External move complete")
                self.stop_robot()
                self.external_move_active = False
                self.external_move_params = None
                return
            direction = 1 if params['ticks'] > 0 else -1
            self.cmd_msg.header.stamp = rospy.Time.now()
            self.cmd_msg.v = params['speed'] * direction
            self.cmd_msg.omega = 0.0
            self.pub.publish(self.cmd_msg)
            return

        # Break between square tasks
        if self.break_start is not None:
            if (rospy.Time.now() - self.break_start) < self.break_time:
                return
            self.break_start = None

        # Start new square task
        if self.current_task is None:
            if not self.tasks:
                rospy.loginfo("Square pattern completed!")
                self.is_running = False
                return
            self.current_task = self.tasks.pop(0)
            self.current_task['start'] = self.right_ticks
            rospy.loginfo(f"Starting {self.current_task['action']}")

        # Execute square task
        task_complete = False
        if self.current_task['action'] == 'move':
            task_complete = self.move_distance(self.current_task['ticks'], self.current_task['start'])
        elif self.current_task['action'] == 'turn':
            task_complete = self.turn_90_deg(self.current_task['ticks'], self.current_task['start'])

        if task_complete:
            self.current_task = None
            self.stop_robot()
            if self.tasks:
                self.break_start = rospy.Time.now()

    def move_custom_distance(self, distance_meters, speed):
 
        rospy.loginfo(f"Starting custom move: {distance_meters} meters at {speed} m/s")

        # Calculate how many encoder ticks are needed for the distance
        target_ticks = int(distance_meters * self.ticks_per_meter)
        start_ticks = self.right_ticks
        rate = rospy.Rate(100)  # 100 Hz loop

        while not rospy.is_shutdown():
            current_ticks = self.right_ticks - start_ticks
            if abs(current_ticks) >= abs(target_ticks):
                rospy.loginfo("Custom move complete.")
                break

            direction = 1 if target_ticks - current_ticks > 0 else -1
            self.cmd_msg.header.stamp = rospy.Time.now()
            self.cmd_msg.v = abs(speed) * direction
            self.cmd_msg.omega = 0.0
            self.pub.publish(self.cmd_msg)
            rate.sleep()

        self.stop_robot()


    def run(self):
        rospy.spin()

if __name__ == '__main__':
    try:
        closed_loop_square = ClosedLoopSquare()
        
        # Give some time for the ROS system to settle
        rospy.sleep(2.0)

        # Demonstrate forward motion: 1 meter at 0.3 m/s
        closed_loop_square.move_custom_distance(1.0, 0.3)
        
        # Pause before next movement
        rospy.sleep(2.0)

        # Demonstrate backward motion: -0.5 meter at 0.2 m/s
        closed_loop_square.move_custom_distance(-0.5, 0.2)

        # Then enter spin loop to keep node alive
        closed_loop_square.run()
    except rospy.ROSInterruptException:
        pass
    except Exception as e:
        rospy.logerr(f"Error in main: {str(e)}")
